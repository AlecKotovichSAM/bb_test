-- GUESTS
-- Таблица для хранения информации о гостях (нормализация)
CREATE TABLE guests (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    guest_name VARCHAR(255) NOT NULL,
    user_id BIGINT,
    CONSTRAINT fk_guest_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Добавляем колонку guest_id в event_guests
ALTER TABLE event_guests ADD COLUMN guest_id BIGINT;
ALTER TABLE event_guests ADD CONSTRAINT fk_event_guest_guest FOREIGN KEY (guest_id) REFERENCES guests(id);

-- Мигрируем данные из event_guests в guests
-- Создаем записи в guests на основе уникальных комбинаций guest_name и user_id из event_guests
INSERT INTO guests (guest_name, user_id)
SELECT DISTINCT guest_name, user_id
FROM event_guests
WHERE guest_name IS NOT NULL;

-- Обновляем event_guests, связывая их с guests
UPDATE event_guests eg
SET guest_id = g.id
FROM guests g
WHERE eg.guest_name = g.guest_name 
  AND (eg.user_id = g.user_id OR (eg.user_id IS NULL AND g.user_id IS NULL));

-- Делаем guest_id обязательным
-- ВАЖНО: При создании нового события с новым гостем в приложении:
-- 1. Сначала создается/находится Guest в таблице guests
-- 2. Затем создается EventGuest с guest_id из созданного Guest
-- Это гарантирует, что guest_id всегда будет заполнен при создании EventGuest
ALTER TABLE event_guests ALTER COLUMN guest_id SET NOT NULL;

-- Удаляем старые колонки guest_name и user_id из event_guests
ALTER TABLE event_guests DROP COLUMN guest_name;
ALTER TABLE event_guests DROP COLUMN user_id;

-- Обновляем внешний ключ для guest_tokens (теперь ссылается на event_guests, но это правильно)
-- guest_tokens уже ссылается на event_guests.id, так что ничего менять не нужно

-- Обновляем внешний ключ для guest_children (теперь guest_id в guest_children ссылается на event_guests.id)
-- guest_children уже ссылается на event_guests.id, так что ничего менять не нужно
