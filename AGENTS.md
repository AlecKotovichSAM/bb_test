# AGENTS.md - Руководство для AI агентов

## AutoConfigureMockMvc

### Важно: Правильный импорт

В этом проекте используется **специфичный импорт** для `AutoConfigureMockMvc`:

```java
import org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc;
```

**НЕ использовать:**
```java
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;  // НЕПРАВИЛЬНО
```

### Контекст

Проект использует Spring Boot 4.0.2, где структура пакетов для тестирования изменилась. 
Правильный пакет для `AutoConfigureMockMvc` в Spring Boot 4.x:
- `org.springframework.boot.webmvc.test.autoconfigure.AutoConfigureMockMvc`

### Использование в тестах

```java
@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
@Transactional
class MyControllerIntegrationTest {
    @Autowired
    private MockMvc mockMvc;
    
    // тесты...
}
```

### Зависимости

Для работы `AutoConfigureMockMvc` требуется:
- `spring-boot-starter-test` (включает MockMvc)
- `spring-boot-starter-webmvc-test` (специфичная зависимость для Spring Boot 4.x)

---

## TestRestTemplate для E2E тестов

### Важно: Правильный импорт

В этом проекте используется **специфичный импорт** для `TestRestTemplate` в E2E тестах:

```java
import org.springframework.boot.resttestclient.TestRestTemplate;
```

**НЕ использовать:**
```java
import org.springframework.boot.test.web.client.TestRestTemplate;  // НЕПРАВИЛЬНО
```

### Контекст

Проект использует Spring Boot 4.0.2, где структура пакетов для тестирования изменилась. 
Правильный пакет для `TestRestTemplate` в Spring Boot 4.x:
- `org.springframework.boot.resttestclient.TestRestTemplate`

### Использование в E2E тестах

**ВАЖНО:** В Spring Boot 4.x `TestRestTemplate` не создается автоматически как bean, поэтому его нужно создавать вручную:

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
public abstract class BaseE2ETest {
    @LocalServerPort protected int port;
    protected final TestRestTemplate http = new TestRestTemplate();  // Создается вручную, НЕ через @Autowired
    
    // методы для HTTP запросов...
}
```

**НЕ использовать:**
```java
@Autowired protected TestRestTemplate http;  // НЕПРАВИЛЬНО - bean не существует
```

### Зависимости

Для работы `TestRestTemplate` требуется:
- `spring-boot-starter-test` (базовые тестовые зависимости)
- `spring-boot-starter-restclient-test` (специфичная зависимость для TestRestTemplate в Spring Boot 4.x)
- `spring-boot-starter-webmvc-test` (дополнительные тестовые зависимости)

**ВАЖНО:** В Spring Boot 4.x `TestRestTemplate` создается вручную, а не через `@Autowired`:
```java
protected final TestRestTemplate http = new TestRestTemplate();
```

---

## Другие важные заметки

### JDK версия

**ВАЖНО:** Проект использует JDK 25.0.2.

Правильный путь к JDK:
```
c:\Work\dist\JDK\jdk-25.0.2
```

При компиляции или запуске тестов убедитесь, что используется именно эта версия JDK.

### Проверка компиляции через Maven

**КРИТИЧЕСКИ ВАЖНО:** После любых изменений кода **ОБЯЗАТЕЛЬНО** проверять компиляцию через Maven с правильной JDK перед завершением работы.

Команда для проверки компиляции:
```powershell
cd c:\Work\Projects\000--LEADS--000\BirthdayBuddy\vibecoding\bb_test
$env:JAVA_HOME = "c:\Work\dist\JDK\jdk-25.0.2"
mvn compile
```

**Правило:** Если компиляция не прошла успешно (BUILD SUCCESS), изменения считаются неполными и должны быть исправлены немедленно. Не полагаться только на линтер IDE - проверять через Maven.

### ObjectMapper в тестах

В интеграционных тестах `ObjectMapper` создается вручную с поддержкой Java 8 time types:

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

private final ObjectMapper objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());
```

Причина: `ObjectMapper` не всегда доступен как bean в тестовом контексте, поэтому создается напрямую. 
Модуль `JavaTimeModule` необходим для сериализации/десериализации `LocalDateTime` и других Java 8 time types.

### Тестовая конфигурация

- Профиль: `@ActiveProfiles("test")`
- База данных: in-memory H2 (`jdbc:h2:mem:testdb`)
- Flyway: включен (миграции выполняются перед тестами)
- Hibernate DDL: `validate` (схема создается через Flyway)

### Flyway миграции

**КРИТИЧЕСКИ ВАЖНО:** Ни в коем случае нельзя изменять старые файлы миграций!

**Правила работы с миграциями:**

1. **Старые миграции НЕЛЬЗЯ изменять** - они уже применены к базе данных, и Flyway проверяет их чексумму. Изменение существующей миграции приведет к ошибке валидации чексуммы.

2. **Для изменений схемы создавать новые миграции** - если нужно изменить структуру БД, создается новая миграция с следующим номером версии (например, `V9__description.sql`).

3. **Рефакторинг через новые миграции** - если нужно перенести данные из одной структуры в другую (например, вынести поле в отдельную таблицу), это делается через новую миграцию, которая:
   - Создает новую структуру
   - Переносит данные из старой структуры в новую
   - Удаляет старую структуру (если необходимо)

**Пример правильного рефакторинга:**
- Миграция V6 создает поле `avatar` в таблице `users`
- Миграция V7 заполняет это поле данными
- Миграция V8 создает таблицу `user_avatars`, переносит данные из `users.avatar` в `user_avatars`, и удаляет колонку `avatar` из `users`
- Все три миграции остаются неизменными, изменения только через новые миграции

**Правило:** Если миграция уже применена к базе данных, она становится неизменяемой. Все изменения схемы делаются через новые миграции.

### Покрытие изменений тестами

**КРИТИЧЕСКИ ВАЖНО:** Все новые изменения в коде должны быть покрыты тестами.

**Правила:**

1. **Новые функции требуют тестов** - при добавлении нового функционала (новые endpoints, методы, сущности) необходимо создать соответствующие тесты
2. **Изменения в существующем коде требуют тестов** - при изменении поведения существующего кода нужно обновить или добавить тесты
3. **Рефакторинг требует тестов** - при рефакторинге необходимо убедиться, что существующие тесты проходят, и добавить новые, если нужно
4. **Тесты должны быть написаны до или вместе с кодом** - не откладывать написание тестов на потом

**Что должно быть покрыто тестами:**

- **Новые API endpoints:**
  - Тесты на успешные сценарии (happy path)
  - Тесты на валидацию входных данных
  - Тесты на обработку ошибок (404, 400, 500)
  - Тесты на edge cases и граничные условия

- **Новые сущности и репозитории:**
  - Тесты на создание, чтение, обновление, удаление (CRUD)
  - Тесты на каскадные операции
  - Тесты на связи между сущностями

- **Новая бизнес-логика:**
  - Тесты на все ветки условий
  - Тесты на обработку исключительных ситуаций
  - Тесты на производительность (если критично)

**Примеры:**

- Добавлен новый endpoint `GET /api/children/{id}/avatar` → нужны тесты на получение аватара, обработку отсутствия аватара, обработку несуществующего ребенка
- Добавлена новая сущность `ChildAvatar` → нужны тесты на создание, чтение, удаление аватара
- Изменен метод создания ребенка для поддержки аватара → нужны тесты на создание с аватаром и без аватара

**Правило:** Если новая функциональность была добавлена без тестов, это считается неполной реализацией. Тесты должны быть добавлены немедленно.

### Покрытие багов тестами

**ВАЖНО:** Все исправленные баги должны быть покрыты тестами.

При исправлении любого бага:
1. **Создать тест**, который воспроизводит баг (должен падать до исправления)
2. **Исправить баг** в коде
3. **Убедиться**, что тест проходит после исправления

Примеры багов, которые должны быть покрыты тестами:
- Исправление `id=0` при создании сущностей (например, `testCreateEvent_WithIdZero_ShouldFixAndCreate`)
- Автоматическая установка значений по умолчанию (например, статус 'Draft' для событий)
- Каскадное удаление связанных данных (например, удаление события со всеми гостями и детьми)
- Валидация и обработка некорректных данных
- Обработка edge cases и граничных условий

**Правило:** Если баг был исправлен без теста, это считается неполным исправлением. Тест должен быть добавлен немедленно.

### Проверка неиспользуемых импортов

**ВАЖНО:** После любых изменений кода необходимо проверять и удалять неиспользуемые импорты.

**Правила:**
1. **Проверять импорты** во всех измененных файлах перед завершением работы
2. **Удалять неиспользуемые импорты** - они загромождают код и могут вызывать путаницу
3. **Использовать IDE** или линтер для автоматического обнаружения неиспользуемых импортов
4. **Проверять компиляцию** после удаления импортов, чтобы убедиться, что ничего не сломалось

**Примеры неиспользуемых импортов:**
- Импорт класса, который не используется в коде
- Импорт статических методов, которые не вызываются
- Дублирующиеся импорты (например, `java.util.*` и `java.util.HashMap`)

**Правило:** Код должен быть чистым от неиспользуемых импортов. Это улучшает читаемость и поддерживаемость кода.

### Актуализация Swagger документации

**ВАЖНО:** При любых изменениях в API необходимо актуализировать описания Swagger/OpenAPI.

**Правила:**

1. **Обновлять описания при изменении endpoints** - если изменяется поведение endpoint, параметры, формат ответа, нужно обновить аннотации `@Operation`, `@ApiResponse`, `@Parameter`

2. **Добавлять описания для новых endpoints** - все новые endpoints должны иметь полное описание с использованием Swagger аннотаций

3. **Проверять актуальность существующих описаний** - при рефакторинге или изменении логики проверять, соответствуют ли описания реальному поведению

4. **Использовать понятные описания** - описания должны быть на русском языке (если проект использует русский) и четко объяснять назначение endpoint

**Что нужно проверять и обновлять:**

- `@Operation(summary, description)` - краткое и полное описание endpoint
- `@ApiResponse` - все возможные коды ответов и их значения
- `@Parameter` - описание всех параметров (path, query, body)
- `@Tag` - правильная категоризация endpoints по контроллерам

**Правило:** После любых изменений в контроллерах необходимо проверить и актуализировать все Swagger аннотации. Документация API должна всегда соответствовать реальному поведению.

### Создание саммари изменений

**ВАЖНО:** Когда пользователь просит сделать саммари изменений (summary), **НЕ создавать markdown файлы**. 

Пользователь копирует саммари прямо из чата, поэтому нужно предоставить саммари в текстовом виде в ответе, а не создавать файлы типа `API_CHANGES_SUMMARY.md` или подобные.

**Правило:** При запросе саммари - предоставить текст в ответе, без создания файлов.
